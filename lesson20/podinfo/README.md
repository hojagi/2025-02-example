# Deployment
Развернём Deployment в кластере, выполнив команду `kubectl apply -f deployment.yaml`.  
Создался один под:
```
NAME                       READY   STATUS    RESTARTS   AGE
podinfo-7bcd95b4b6-fknr2   1/1     Running   0          8s 
```
Проверим работу приложения. Для этого сделаем под доступным локально с помощью команды `kubectl port-forward podinfo-7bcd95b4b6-fknr2 9000:9000` и отправим с помощью утилиты `curl` POST-запрос на endpoint `/store`:
```
curl -X POST -d '{"application": "stateful"}' localhost:9000/store
{
  "hash": "60551111de9edc71337c0d121f83aaf80c776f43"
} 
```
В ответе мы получаем хеш-значение переданных данных. Это значение соответствует имени файла в директории `/data`, в который записалось переданное значение.
Проверим это, отправив GET-запрос на получение данных:
```
curl localhost:9000/store/60551111de9edc71337c0d121f83aaf80c776f43
{"application": "stateful"}
```
Посмотрим на содержимое нашего тома. Для этого воспользуемся командой `kubectl exec`, которая позволяет выполнить переданную команду внутри контейнера:
```
kubectl exec podinfo-7bcd95b4b6-fknr2 -- ls /data.
60551111de9edc71337c0d121f83aaf80c776f43 
```
Как видите, в директории есть файл, имя которого соответствует нашему хешу. Проверим содержимое файла с помощью команды
```
kubectl exec podinfo-7bcd95b4b6-fknr2 -- cat /data/60551111de9edc71337c0d121f83aaf80c776f43
{"application": "stateful"}
```

Отлично, приложение функционирует и пишет данные на диск.  
Теперь сымитируем перезапуск контейнера и посмотрим, что произойдёт с данными.  
Отправим команду, которая вызывает падение приложения: 
```
curl localhost:9000/panic
```
Получим список подов и убедимся, что контейнер внутри пода перезапущен:
```
NAME                       READY   STATUS    RESTARTS      AGE
podinfo-7bcd95b4b6-fknr2   1/1     Running   1 (31s ago)   24m 
```
Посмотрим на содержимое `/data`: 
```
kubectl exec podinfo-7bcd95b4b6-fknr2 -- ls /data`.
60551111de9edc71337c0d121f83aaf80c776f43 
```
Данные сохранились — теперь они не потеряются в случае рестарта контейнеров внутри пода. Однако приложение может перезапуститься и по другим причинам, например, если удалится под, если он запустится на новом узле, если вышестоящий объект пересоздаст поды, развёртывая новую версию. Что тогда произойдёт с данными в томах?
Чтобы это узнать, удалим текущий под: `kubectl delete pod podinfo-7bcd95b4b6-fknr2`. После удаления Deployment развернул новый под:
```
NAME                       READY   STATUS    RESTARTS   AGE
podinfo-7bcd95b4b6-tjwk6   1/1     Running   0          12s 
```
Посмотрим на содержимое директории с данными приложения:
```
kubectl exec podinfo-7bcd95b4b6-fknr2 -- ls -l /data.
total 0 
```
Как видите, в директории пусто. Всё из-за эфемерности тома emptyDir: данные в нём доступны, пока доступен под, использующий этот том. Для вновь созданного пода создаётся новый том, старый же удаляется. 

# StatefulSet
Задеплоим StatefulSet и Service в кластер:
```
kubectl apply -f statefulset.yaml
```
Получим список подов, выполнив команду
```
kubectl get pod
```
Имена подов генерируются теперь по другому принципу: к имени пода дописывается индекс, а не случайный набор символов. Теперь у каждого пода есть своё постоянное имя, которое не поменяется, если пересоздать под.  
Каждый экземпляр приложения имеет свой уникальный сетевой идентификатор, при работе со stateful-приложением важно обращаться к конкретной реплике. На практике с помощью StatefulSet часто разворачивают различные распределённые системы и базы данных, компоненты которых взаимодействуют между собой. В таком случае компоненты системы должны знать адреса остальных экземпляров — тут и поможет наличие постоянного имени. Создаваемый Headless Service позволяет приложениям в Kubernetes получить адрес конкретного пода StatefulSet по его имени.
А ещё с помощью постоянного идентификатора пода Kubernetes может связывать конкретный под с соответствующим ему постоянным томом.  

Посмотрим на список объектов PVC. Для каждого пода созданы claim с именем `<имя тома из шаблона>-<имя пода>`. Теперь каждый экземпляр приложения надёжно связан со своим хранилищем, а в случае перезапуска под получит то же имя и соответствующий постоянный том.  

Рассмотрим процесс обновления приложения, которое управляется StatefulSet.  
Отправим запрос к каждому экземпляру приложения — для этого в дополнительных терминалах выполним команды port-forward для доступа к подам:
```
kubectl port-forward podinfo-0 9000:9000
```
`podinfo-0` будет доступен по адресу `localhost:9000`;
```
kubectl port-forward podinfo-1 9001:9000
```
`podinfo-1` будет доступен по адресу `localhost:9001`.  

Отправим запрос к поду `podinfo-0`:
```
curl -X POST -d '{"pod index": "0"}' localhost:9000/store.
{
  "hash": "98b746746c95976ebf7333cebc5eea3e904c7faa"
} 
```
Отправим запрос к поду `podinfo-1`:
```
curl -X POST -d '{"pod index": "1"}' localhost:9001/store.
{
  "hash": "dd91cc7b3c6cfa1a03c69a306049af275429f00d"
}
```
Откорректируем манифест, изменив версию образа на 6.7.0. В отдельном терминале выполним команду `kubectl get pod --watch`, затем применим изменения манифеста с помощью команды `kubectl apply -f statefulset.yaml` и посмотрим на процесс обновления подов:
```
NAME        READY   STATUS              RESTARTS   AGE
podinfo-0   1/1     Running             0          38s
podinfo-1   1/1     Running             0          25s
podinfo-1   1/1     Terminating         0          40s
podinfo-1   0/1     Terminating         0          44s
podinfo-1   0/1     Pending             0          0s
podinfo-1   0/1     ContainerCreating   0          6s
podinfo-1   1/1     Running             0          7s
podinfo-0   1/1     Terminating         0          64s
podinfo-0   0/1     Pending             0          0s
podinfo-0   0/1     ContainerCreating   0          0s
podinfo-0   1/1     Running             0          9s
```
StatefulSet обновляет поды в порядке, обратном их созданию: сначала обновился под `podinfo-1`, а затем — `podinfo-0`. 
После перезапуска подов снова откроем доступ к ним с помощью команды `port-forward` и убедимся, что данные в томах сохранились. Для этого отправим GET-запросы к подам:
```
curl localhost:9000/store/98b746746c95976ebf7333cebc5eea3e904c7faa;
{"pod index": "0"} 
curl localhost:9001/store/dd91cc7b3c6cfa1a03c69a306049af275429f00d.
{"pod index": "1"}
```
Как видите, после обновления к поду монтируется тот же постоянный том. Таким образом, мы можем обновлять приложения, не переживая о потере данных. Однако стоит понимать, как новая версия приложения будет работать с данными старой версии. Если данные в томах могут привести к ошибкам в новой версии приложения, необходимо предварительно очистить их или удалить тома перед развёртыванием новой версии. 